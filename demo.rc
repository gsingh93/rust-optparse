use std::os;
use optparse::*;

mod optparse;

fn main() {
	// first, define the options that the command supports
	let simple_opt = Opt::new("-o", "--opt", "A simple option");
	let opt_with_opt_arg = Opt::new("-a", "--opt-with-arg [ARG]", "An option taking an optional argument");
	let opt_with_req_arg = Opt::new("-r", "--required-arg ARG", "An option taking a required argument");
	let long_opt = Opt::new("", "--long-opt", "An option with no short variant");
	let int_arg = Opt::new("-i", "--int-arg [ARG]", "Option that takes an int arg");
	let multi_value_arg = Opt::new("-m", "--multi-arg [ARGS]", "Option that can be repeated");

	// specify the syntax, banner and options for the command
	let opt_parser = OptionParser {
		usage : ~"[<values to print>...]",
		banner : ~"This is an example app for the optparser module. \
		           The banner is a short summary which appears at the top of
		           --help output",
		opts : ~[&simple_opt, &opt_with_opt_arg, &long_opt, &int_arg, &opt_with_req_arg,
		         &multi_value_arg],
		tail_banner : Some(~"This is a tail banner that appears below the list of options")
	};

	let flags = opt_parser.parse(os::args());

	match flags.status {
		Help => return,
		Error => {
			os::set_exit_status(1);
			return
		},
		_ => ()
	}

	// handle options
	if opt_parser.is_set(&flags, &simple_opt) {
		println("An option with no args was used");
	}

	do opt_parser.with_value(&flags, &opt_with_opt_arg) |val| {
		println(fmt!("An option with optional arg %s was used", val));
	}

	do opt_parser.with_value(&flags, &opt_with_req_arg) |val| {
		println(fmt!("An option with required arg %s was used", val));
	}

	match opt_parser.value(&flags, &opt_with_opt_arg) {
		Some(v) => println(fmt!("An option with an optional arg %s was used", v)),
		None => ()
	}

	let multi_opt_values = opt_parser.values(&flags, &multi_value_arg);
	for val in multi_opt_values.iter() {
		println(fmt!("Multi-value arg: %s", *val));
	}

	do opt_parser.with_value(&flags, &int_arg) |val| {
		match std::int::from_str(val) {
			Some(int_val) =>
				println(fmt!("An option which expects an int arg was used: %d", int_val)),
			None =>
				println(fmt!("%s expects a numeric arg", int_arg.long))
		}
	}

	// handle remaining args
	for (i, arg) in flags.args.iter().enumerate() {
		println(fmt!("Non-option argument #%u: %s", i, *arg));
	}
}
